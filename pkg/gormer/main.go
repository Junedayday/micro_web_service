package main

import (
	"database/sql"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
)

const (
	gormerHeader = `// Code generated by gormer. DO NOT EDIT.
package %s

import "time"
`
	daoHeader = `// Code generated by gormer. DO NOT EDIT.
package %s

import (
	"time"
	
	"github.com/pkg/errors"
	"gorm.io/gorm"
	
	"%s/%s"
)
`
)

var Viper = viper.New()

func main() {
	var configFilePath = flag.String("c", "./", "config file path")
	flag.Parse()

	Viper.SetConfigName("gormer")        // config file name without file type
	Viper.SetConfigType("yaml")          // config file type
	Viper.AddConfigPath(*configFilePath) // config file path
	if err := Viper.ReadInConfig(); err != nil {
		panic(err)
	} else if err = Viper.UnmarshalKey("database.tables", &tableInfo); err != nil {
		panic(err)
	}
	fmt.Printf("%+v\n", tableInfo)

	var (
		dsn         = Viper.GetString("database.dsn")
		projectPath = Viper.GetString("project.base")
		goMod       = Viper.GetString("project.go_mod")
		gormPath    = Viper.GetString("project.gorm")
		daoPath     = Viper.GetString("project.dao")
	)

	if dsn == "" || projectPath == "" || gormPath == "" || daoPath == "" || goMod == "" {
		fmt.Println("dsn,projectPath,gormPath,daoPath,goMod 为必填参数，请检查")
		os.Exit(1)
	}

	// 创建文件夹（如果已存在会报错，不影响）
	for _, path := range []string{projectPath + gormPath, projectPath + daoPath} {
		os.MkdirAll(path, os.ModePerm)
	}

	// 连接mysql
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		panic(err)
	}
	defer db.Close()

	fmt.Println("start to generate gorm structs")

	// 读取数据库中的表
	tables, err := getAllTables(db)
	if err != nil {
		fmt.Printf("getAllTables error %+v", err)
		os.Exit(1)
	}

	tMatcher := getTableMatcher()

	for _, table := range tables {
		// 1.生成结构
		structResult, err := Generate(db, table, tMatcher[table])
		if err != nil {
			fmt.Printf("Generate table %s error %+v", table, err)
			os.Exit(1)
		}

		// 2.生成gormer file
		if gormPath[len(gormPath)-1] == '/' {
			gormPath = gormPath[:len(gormPath)-1]
		}
		dirs := strings.Split(gormPath, "/")
		header := fmt.Sprintf(gormerHeader, dirs[len(dirs)-1])
		err = parseToFile(projectPath+gormPath, tMatcher[table], header, structResult, parseToGormerTmpl)
		if err != nil {
			fmt.Printf("parseToFile error %+v\n", err)
			os.Exit(1)
		}

		// 3.生成dao file
		if daoPath[len(daoPath)-1] == '/' {
			daoPath = daoPath[:len(daoPath)-1]
		}
		dirs = strings.Split(daoPath, "/")
		header = fmt.Sprintf(daoHeader, dirs[len(dirs)-1], goMod, gormPath)
		err = parseToFile(projectPath+daoPath, tMatcher[table], header, structResult, parseToDaoTmpl)
		if err != nil {
			fmt.Printf("parseToFile error %+v\n", err)
			os.Exit(1)
		}

		fmt.Printf("Generate Table %s Finished\n", table)
	}

	// go fmt files
	exec.Command("go", "fmt", gormPath+"...").Run()
}

func parseToFile(filePath string, matchInfo TableInfo, fileHeader string, structResult StructLevel, parseFunc func(StructLevel) (string, error)) error {
	result, err := parseFunc(structResult)
	if err != nil {
		return errors.Wrapf(err, "parseToDaoTmpl structResult %v", structResult)
	}
	path := fmt.Sprintf("%s/%s.go", filePath, matchInfo.GoStruct)
	file, err := os.OpenFile(path, os.O_WRONLY+os.O_CREATE+os.O_TRUNC, os.ModePerm)
	if err != nil {
		return errors.Wrapf(err, "OpenFile path %s", path)
	}
	defer file.Close()

	_, err = file.WriteString(fileHeader + result)
	if err != nil {
		return errors.Wrap(err, "WriteString to file")
	}
	return nil
}
