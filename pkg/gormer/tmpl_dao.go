package main

const (
	daoHeader = `// Code generated by gormer. DO NOT EDIT.
package %s

import (
	"context"
	"time"
	
	"github.com/pkg/errors"
	"gorm.io/gorm"
	
	"%s/%s"
	"%s/%s"
)
`
	daoExtHeader = `package %s
	
// Implement ext method here
`
)

var (
	daoTmplRepo = `
type {{.StructName.UpperS}}Repo struct {
	db *gorm.DB
}

func New{{.StructName.UpperS}}Repo(db *gorm.DB) *{{.StructName.UpperS}}Repo {
	return &{{.StructName.UpperS}}Repo{db: db}
}

var _ model.{{.StructName.UpperS}}Model = New{{.StructName.UpperS}}Repo(nil)

`
	daoTmplAdd = `
func (repo *{{.StructName.UpperS}}Repo) Add{{.StructName.UpperS}}(ctx context.Context, {{.StructName.LowerS}} *gormer.{{.StructName.UpperS}}) (err error) {
{{if ne .FieldCreateTime "" }}
    if {{.StructName.LowerS}}.{{.FieldCreateTime}}.IsZero() {
		{{.StructName.LowerS}}.{{.FieldCreateTime}} = time.Now()
	}
{{end}}
{{if ne .FieldUpdateTime "" }}
    if {{.StructName.LowerS}}.{{.FieldUpdateTime}}.IsZero() {
		{{.StructName.LowerS}}.{{.FieldUpdateTime}} = time.Now()
	}
{{end}}
	repo.db.WithContext(ctx).
		Table(gormer.{{.StructName.UpperS}}TableName).
		Create({{.StructName.LowerS}})
	err = repo.db.Error
	return
}

func (repo *{{.StructName.UpperS}}Repo) Add{{.StructName.UpperS}}s(ctx context.Context, {{.StructName.LowerP}} []*gormer.{{.StructName.UpperS}}) (err error) {
	{{if ne .FieldCreateTime "" }}
	for i := range {{.StructName.LowerP}} {
        if {{.StructName.LowerP}}[i].{{.FieldCreateTime}}.IsZero() {
			{{.StructName.LowerP}}[i].{{.FieldCreateTime}} = time.Now()
		}
	}
	{{end}}
	
	{{if ne .FieldUpdateTime "" }}
	for i := range {{.StructName.LowerP}} {
        if {{.StructName.LowerP}}[i].{{.FieldUpdateTime}}.IsZero() {
			{{.StructName.LowerP}}[i].{{.FieldUpdateTime}} = time.Now()
		}
	}
	{{end}}
	
	
	repo.db.WithContext(ctx).
		Table(gormer.{{.StructName.UpperS}}TableName).
		Create({{.StructName.LowerP}})
	err = repo.db.Error
	return
}
`
	daoTmplQuery = `
func (repo *{{.StructName.UpperS}}Repo) Query{{.StructName.UpperP}}(ctx context.Context, pageNumber, pageSize int, condition *gormer.{{.StructName.UpperS}}Options) ({{.StructName.LowerP}} []gormer.{{.StructName.UpperS}}, err error) {
	db := repo.db
	if condition != nil {
		for _, field := range condition.Fields {
	        db.Where(field + " = ?", condition.{{.StructName.UpperS}}.GetValueByField(gormer.{{.StructName.UpperS}}Field(field)))
		}
	}
{{if ne .FieldSoftDeleteKey "" }}
	db = db.Where("{{.TableSoftDeleteKey}} != ?", gormer.{{.StructName.UpperS}}{{.FieldSoftDeleteKey}}SoftDeleted)
{{ end }}
	db.WithContext(ctx).
		Table(gormer.{{.StructName.UpperS}}TableName).
		Limit(pageSize).
		Offset((pageNumber - 1) * pageSize).
		Find(&{{.StructName.LowerP}})
	err = repo.db.Error
	return
}

`
	daoTmplCount = `func (repo *{{.StructName.UpperS}}Repo) Count{{.StructName.UpperS}}s(ctx context.Context, condition *gormer.{{.StructName.UpperS}}Options) (count int64, err error) {
	db := repo.db
	if condition != nil {
	    for _, field := range condition.Fields {
	        db.Where(field + " = ?", condition.{{.StructName.UpperS}}.GetValueByField(gormer.{{.StructName.UpperS}}Field(field)))
		}
	}
{{if ne .FieldSoftDeleteKey "" }}
	db = db.Where("{{.TableSoftDeleteKey}} != ?", gormer.{{.StructName.UpperS}}{{.FieldSoftDeleteKey}}SoftDeleted)
{{ end }}
	db.WithContext(ctx).
		Table(gormer.{{.StructName.UpperS}}TableName).
		Count(&count)
	err = repo.db.Error
	return
}

`
	daoTmplUpdate = `func (repo *{{.StructName.UpperS}}Repo) Update{{.StructName.UpperS}}(ctx context.Context, updated, condition *gormer.{{.StructName.UpperS}}Options) (err error) {
	if updated == nil || len(updated.Fields) == 0 {
		return errors.New("update must choose certain fields")
	} else if condition == nil {
		return errors.New("update must include where condition")
	}
{{if ne .FieldUpdateTime "" }}
    if updated.{{.StructName.UpperS}}.{{.FieldUpdateTime}}.IsZero() {
		updated.{{.StructName.UpperS}}.{{.FieldUpdateTime}} = time.Now()
		updated.Fields = append(updated.Fields, "{{.TableUpdateTime}}")
	}
{{end}}
	repo.db.WithContext(ctx).
		Table(gormer.{{.StructName.UpperS}}TableName).
		Where(condition.{{.StructName.UpperS}}, condition.Fields).
		Select(updated.Fields).
		Updates(updated.{{.StructName.UpperS}})
	err = repo.db.Error
	return
}

`
	daoTmplDelete = `func (repo *{{.StructName.UpperS}}Repo) Delete{{.StructName.UpperS}}(ctx context.Context, condition *gormer.{{.StructName.UpperS}}Options) (err error) {
	if condition == nil {
		return errors.New("delete must include where condition")
	}

	repo.db.WithContext(ctx).
        Table(gormer.{{.StructName.UpperS}}TableName).
		Where(condition.{{.StructName.UpperS}}, condition.Fields).
{{if eq .FieldSoftDeleteKey "" }} Delete(&gormer.{{.StructName.UpperS}}{})
{{ else }}  {{if eq .FieldUpdateTime "" }}
				Select("{{.TableSoftDeleteKey}}").
				Updates(&gormer.{{.StructName.UpperS}}{
					{{.FieldSoftDeleteKey}}:gormer.{{.StructName.UpperS}}{{.FieldSoftDeleteKey}}SoftDeleted,
				})
            {{ else }}
                Select("{{.TableSoftDeleteKey}}","{{.TableUpdateTime}}").
				Updates(&gormer.{{.StructName.UpperS}}{
					{{.FieldSoftDeleteKey}}:gormer.{{.StructName.UpperS}}{{.FieldSoftDeleteKey}}SoftDeleted,
					{{.FieldUpdateTime}} : time.Now(),
				})
            {{ end }}
{{ end }}
	err = repo.db.Error
	return
}

`

	daoTmplGenQuery = `
{{range $item := .GenQueries}}
// Query{{$item.Method}} {{$item.Desc}}
func (repo *{{$.StructName.UpperS}}Repo) Query{{$item.Method}}(ctx context.Context,{{range $match := $item.Args}} {{$match.Name}} {{$match.Type}}, {{end}}pageNumber, pageSize int, condition *gormer.{{$.StructName.UpperS}}Options) ({{$.StructName.LowerP}} []gormer.{{$.StructName.UpperS}}, err error) {
	
	{{if ne $item.Where "" }} repo.db = repo.db.Where("{{$item.Where}}",{{$c := counter}}{{range $match := $item.Args}} {{if call $c}}, {{end}}{{$match.Name}} {{end}})
	{{ end }}
	{{if ne $item.OrderBy "" }} repo.db = repo.db.Order("{{$item.OrderBy}}")
	{{ end }}

	return repo.Query{{$.StructName.UpperP}}(ctx, pageNumber, pageSize, condition)
}

// Count{{$item.Method}} {{$item.Desc}}
func (repo *{{$.StructName.UpperS}}Repo) Count{{$item.Method}}(ctx context.Context,{{range $match := $item.Args}} {{$match.Name}} {{$match.Type}}, {{end}} condition *gormer.{{$.StructName.UpperS}}Options) (count int64, err error) {
	
	{{if ne $item.Where "" }} repo.db = repo.db.Where("{{$item.Where}}",{{$c := counter}}{{range $match := $item.Args}} {{if call $c}}, {{end}}{{$match.Name}} {{end}})
	{{ end }}

	return repo.Count{{$.StructName.UpperP}}(ctx, condition)
}
{{end}}
`

	daoTmpl = daoTmplRepo + daoTmplAdd + daoTmplQuery + daoTmplCount + daoTmplUpdate + daoTmplDelete + daoTmplGenQuery
)
