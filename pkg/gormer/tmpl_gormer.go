package main

const (
	gormerHeader = `// Code generated by gormer. DO NOT EDIT.
package %s

import "time"
`
)

var gormerTmpl = `
// Table Level Info
const {{.StructName.UpperS}}TableName = "{{.TableName}}"

// Field Level Info
type {{.StructName.UpperS}}Field string
const (
{{range $item := .Columns}}
    {{$.StructName.UpperS}}Field{{$item.FieldName}} {{$.StructName.UpperS}}Field = "{{$item.GormName}}" {{end}}
)

{{if ne .FieldSoftDeleteKey "" }}
const {{.StructName.UpperS}}{{.FieldSoftDeleteKey}}SoftDeleted = {{.TableSoftDeleteValue}}
{{ end }}

var {{$.StructName.UpperS}}FieldAll = []{{$.StructName.UpperS}}Field{ {{range $k,$item := .Columns}}"{{$item.GormName}}", {{end}}}

// Kernel struct for table for one row
type {{.StructName.UpperS}} struct { {{range $item := .Columns}}
	{{$item.FieldName}}	{{$item.FieldType}}	` + "`" + `gorm:"column:{{$item.GormName}}"` + "`" + ` // {{$item.Comment}} {{end}}
}

// Kernel struct for table operation
type {{.StructName.UpperS}}Options struct {
    {{.StructName.UpperS}} *{{.StructName.UpperS}}
    Fields []string
}

// Match: case insensitive
var {{$.TableName}}FieldMap = map[string]string{
{{range $item := .Columns}}"{{$item.FieldName}}":"{{$item.GormName}}","{{$item.GormName}}":"{{$item.GormName}}",
{{end}}
}

func New{{.StructName.UpperS}}Options(target *{{.StructName.UpperS}}, fields ...{{$.StructName.UpperS}}Field) *{{.StructName.UpperS}}Options{
    options := &{{.StructName.UpperS}}Options{
        {{.StructName.UpperS}}: target,
        Fields: make([]string, len(fields)),
    }
    for index, field := range fields {
        options.Fields[index] = string(field)
    }
    return options
}

func New{{.StructName.UpperS}}OptionsAll(target *{{.StructName.UpperS}}) *{{.StructName.UpperS}}Options{
    return New{{.StructName.UpperS}}Options(target, {{$.StructName.UpperS}}FieldAll...)
}

func New{{.StructName.UpperS}}OptionsRawString(target *{{.StructName.UpperS}}, fields ...string) *{{.StructName.UpperS}}Options{
    options := &{{.StructName.UpperS}}Options{
        {{.StructName.UpperS}}: target,
    }
    for _, field := range fields {
        if f,ok := {{$.TableName}}FieldMap[field];ok {
             options.Fields = append(options.Fields, f)
        }
    }
    return options
}
`
